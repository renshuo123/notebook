



# 软件测试基础

## 阶段性目标

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011201687.png" alt="image-20230201120110610" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011201825.png" alt="image-20230201120142787" style="zoom: 80%;" />

## 认识软件及测试

### 接口请求过程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011206527.png" alt="image-20230201120621487" style="zoom: 80%;" />

### 软件产生过程⭐

![image-20230201121034646](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011210765.png)

### 软件测试目的

> 使用技术手段验证软件是否满足需求

![image-20230201121203272](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011212336.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011213196.png" alt="image-20230201121304147"  />



## 测试主流技能⭐

### 功能测试

程序功能是否满足需求

![image-20230201131431138](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011314220.png)

### 自动化测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011316725.png" alt="image-20230201131607684" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011316853.png" alt="image-20230201131624816" style="zoom:67%;" />

### 接口测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011317298.png" alt="image-20230201131737200" style="zoom:67%;" />

![image-20230201131804488](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011318583.png)

### 性能测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011322141.png" alt="image-20230201132249058" style="zoom:80%;" />

### 主流方向建议

> 1、功能测试+接口测试 
>
> 2、自动化测试+接口
>
> 3、功能+性能

## 测试常用分类

### 按测试阶段划分

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011330906.png" alt="image-20230201133041833" style="zoom:67%;" />

### 按代码可见度划分

> - 黑盒测试：主要针对功能（阶段划分->系统测试）
> - 灰盒测试：针对接口测试（阶段划分->集成测试）
> - 白盒测试：针对程序源代码进行测试（阶段划分->单元测试）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011334946.png" alt="image-20230201133420883" style="zoom: 80%;" />

> - 系统测试和黑盒测试重点核心是功能测试
> - 集成测试和灰盒测试又称接口测试 
> - 单元测试和白盒测试是对代码进行测试
> - 自动化测试归属功能测试
> - 性能测试、安全测试归属专项测试s

## 质量模型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011451029.png" alt="image-20230201145101975" style="zoom:67%;" />

> 说明：质量模型能告诉我们，测试时应该考虑的方面
>
> 重点：功能、性能、兼容、易用性、安全
>
> 结论：无论测试硬件或软件，都应该从以上几点来进行分类验证

### 功能性

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011453515.png" alt="image-20230201145333459" style="zoom:50%;" />

### 性能

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011454404.png" alt="image-20230201145418343" style="zoom:67%;" />

### 兼容性

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011454598.png" alt="image-20230201145459550" style="zoom:67%;" />

### 易用性

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011455977.png" alt="image-20230201145540926" style="zoom: 50%;" />

### 可靠性

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011457326.png" alt="image-20230201145701279" style="zoom: 67%;" />

### 安全

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011458583.png" alt="image-20230201145811542" style="zoom:80%;" />

### 可移植性

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011459890.png" alt="image-20230201145907781" style="zoom:80%;" />

### 可维护性

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011500952.png" alt="image-20230201150007167" style="zoom:67%;" />

## 测试流程⭐

![image-20211023143542384](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155505.png)

### 需求分析（评审）

```
前提：阅读1遍需求文档，记录不明确之处
参与人员：前端、后端、测试、产品
目的：
	1、确保各部门需求理解一致
	2、各角色对需求进行查漏补缺
	3、了解软件有些功能
提示：需求分析阶段->软件还未实现（刚立项）
```

### 测试计划

```
说明：指导测试执行的文档（重要）
测什么（目标、范围）
谁来测（人员进度及安排）
怎么测（测试工具、测试策略）
```

### 用例设计

```
说明：保证能准确验证软件测试点执行的文档。
1、分析需求
2、提取测试点
3、设计用例覆盖测试点
```

### 用例执行

```
说明：实施测试
```

### 缺陷管理

```
提交->验证->关闭
```

### 测试报告

```
1、bug分析及统计
2、测试中遇到的问题
3、测试总结（本次测试中的优点和不足）
```



## 测试用例

### 什么是用例

用例：**用**户使用的案例生活中的用例

### ![image-20211023153145014](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155506.png)用例的作用

> 1、防止漏测
>
> 2、衡量软件是否通过的标准

### 用例模板⭐

![image-20211223170142537](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155504.png)

![image-20211223170214567](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155514.png)

### 八大要素编写规范

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155343.png" alt="image-20211023161306406" style="zoom:67%;" />

### 微信发朋友圈案例

> 1、成功（1张图片） 
>
> 2、成功（1段文字） 
>
> 3、失败（内容为空）

![image-20211023172649260](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155145.png)

# 解决穷举场景

## 等价类划分法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155563.png" alt="image-20211223165451571" style="zoom:67%;" />

## 验证QQ合法性案例

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155869.png" alt="image-20211223165623505" style="zoom:67%;" />

![image-20211223165637739](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011519347.png)

## 电话号合法验证

```
要求：
1. 区号:空或者是三位数字
2. 前缀码:非“0”且非“1”开头的三位数字
3. 后缀码:四位数字
```

![image-20211223165723688](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155830.png)     ![image-20211223165749559](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011155242.png)

## 应用场景

> 针对：需要有大量数据测试输入，但是没法穷举测试的地方，例如输入框、下拉列表、单选复选框
>
> 典型代表：页面的输入框类测试。
>
> **友情提示：**完整的用例应该是等价类和边界值一块写。



# 解决边界限制问题

> 说明：使用边界值解决边界位数限制问题。

## 边界值分析法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535069.png" alt="image-20211024114728995" style="zoom:67%;" />

```
提示：
	1、有关范围限制，最多7条用例（暂时未优化）
	2、边界值能解决位数限制问题，但是不能解决类型问题（要结合等价类）
```

## 设计步骤

```
1、明确需求
2、确定有效和无效等价
3、确定边界范围
4、提取数据编写用例
```

## 边界值验证标题长度合法

> 需求：通过边界值法验证标题长度的合法性
>
> 要求：标题长度大于0，小于等于30个字符

![image-20211024120514746](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535068.png)

![image-20211024120527142](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535078.png)

## 验证QQ合法性

![image-20211024122700482](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535074.png)

![image-20211024122639248](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535083.png)

## 边界值优化

> 重点：开内闭外（开区间选包含的点，闭区选不包含的点）
>
> 开区间：不包含边界上的点（没有等号）。如：a<10
>
> 闭区间：包含边界上的点（有等号）。 如:a<=10

优化策略：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535079.png" alt="image-20211024145308985" style="zoom:67%;" />

## 边界值总结

> 强调：单个输入框，常用的方式 边界+等价类
>
> 面试题：最常用的用例设计方法有哪些？--等价类、边界值

> 在等价类的基础上针对有边界范围的测试数据输入的地方(重点关注边界)，常见词语描述:**大小、尺寸、重量、最**
>
> **大、最小、至多、至少**等修饰词语，典型代表:有边界范围的输入框类测试



# 解决多条件依赖测试

> 重点：使用判定表

## 判定表定义及组成

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011631803.png" alt="image-20230201163037270" style="zoom: 50%;" />

## 判定表步骤

```
1、明确需求
2、画出判定表
 	1）、列出条件桩和动作桩 
 	2）、填写条件项，对条件进行全组合 
 	3）、根据条件项的组合确定动作项 
 	4）、简化、合并相似规则(有相同的动作)
3、根据规则编写测试用例
```

## 订购单检查

### 需求描述

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011636376.png" alt="image-20230201163638317" style="zoom:67%;" />

### 判定表

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535836.png" alt="image-20211024152653900" style="zoom:67%;" />

### 用例

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535968.png" alt="image-20211024152731367" style="zoom:67%;" />

## 文件修改

### 需求分析

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011650265.png" alt="image-20230201165035214" style="zoom:67%;" />

### 判定表

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535357.png" alt="image-20211024155853521" style="zoom:67%;" />

### 用例

![image-20211024155907864](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535077.png)

## 判定表应用场景

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011654341.png" alt="image-20230201165434272" style="zoom:80%;" />

```
提示：
	1、多条件之间有依赖关系，使用判定表来进行测试覆盖。
	2、判定表一般适合4个以内条件依赖关系
	3、如果条件超过4个，就不适合覆盖所有条件，应采用（正交法）来解决。
```



# 场景法

>  1、覆盖业务测试,需要使用流程图法
>
>  2、先测试业务，在测试单功能、单模块、单页面

## 流程图

>  提示:业务用例是根据流程图来梳理的,需要先了解流程图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011659862.png" alt="image-20230201165958753" style="zoom:50%;" />



## 流程图工具

```
1、线上工具：https://processon.com/diagraming/605880af07912927bd71c388
2、离线工具：visio
3、其他工具：Excel
```

## 登录验证流程图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011705824.png" alt="image-20230201170519771" style="zoom:67%;" />



## ATM取款流程图

### ATM取款流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011707656.png" alt="image-20230201170730587" style="zoom: 80%;" />

### 流程图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011706478.png" alt="image-20211024165931247" style="zoom:80%;" />

![image-20211024165946258](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535906.png)

### 用例

![image-20211024170008639](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535371.png)

# 错误推荐法

> 应用场景：**当项目用例都执行完毕，且BUG修复完成，离上线还有一段时间，在这段时间中可是使用错误推荐法复测主要业务或测试未覆盖的功能**。

![image-20211024171017117](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011535066.png)

# 用例执行

> 说明：执行结果与用例的期望结果不一致（含义），为缺陷。

![image-20211027093138826](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720783.png)



执行失败的用例

![image-20211027095615336](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720782.png)

```
提示：用例执行不通过为缺陷，需要进行缺陷管理
```

# 缺陷

## 定义

> 软件中存在的各种问题，都为缺陷，简称bug；

## 缺陷标准

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011804889.png" alt="image-20230201180444834" style="zoom: 80%;" />

## 缺陷产生的原因

```
1、需求文档
2、架构设计
3、编码实现
4、环境（硬件、软件）
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011811280.png" alt="image-20230201181108204" style="zoom:67%;" />

## 缺陷的生命周期

> 回归测试
>
> ①常规项目回归：项目本次发布新增2个模块，最基本要测新增模块功能及新增模块关联的旧模块。
>
> ②非常规项目（银行、部队、航天）：新增功能，必须全部复测。
>
> 回归bug：上一个版本发现的缺陷，开发修复完毕，在下个版本进行重新验证。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720782.png" alt="image-20211027103536357" style="zoom: 50%;" />

## 缺陷核心要素

![image-20211027110033840](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720781.png)

## 缺陷提交要素

![image-20211027110024249](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720792.png)

## 缺陷类型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011842345.png" alt="image-20230201184226278" style="zoom:67%;" />

```
1、功能错误
2、UI页面错误
3、兼容性
4、数据（数据库）
5、易用性
6、建议
7、架构缺陷
```

## 工作流程（小结）

```
1、设计用例->执行用例（执行测试）->缺陷（提交、验证、关闭）
2、缺陷定义：任何问题（Bug）
3、缺陷标准：多功能、少功能、错误、缺少隐性功能、易用性
4、描述缺陷重点：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注
5、提交缺陷信息：指派人、缺陷等级、修复优先级、类型、状态（统计缺陷）
```

# 缺陷管理

## 缺陷编写

![image-20211027144614178](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720795.png)

## 缺陷编写规范

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011848077.png" alt="image-20230201184856018" style="zoom: 80%;" />

## 缺陷跟踪流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720129.png" alt="image-20211027144711475" style="zoom:67%;" />

```
提示：知道测试和开发流程中涉及的工作即可。
```

## 提交注意事项

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720978.png" alt="image-20211027144811825" style="zoom:80%;" />

```
面试题：发现缺陷后，首先回怎么办？--确定Bug可复现、确定是Bug
提交时，要检查缺陷是否已存在
```

## 缺陷管理工具

```
1、项目管理工具-管理缺陷 (禅道、JIRA、TFS)
2、Excel管理缺陷
```

## 禅道（项目管理工具）⭐

地址：https://demo.zentao.net/user-login.html

### 禅道特点

![image-20211027150242321](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720046.png)

### 使用流程图

![image-20211027150226237](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720445.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011933658.png" alt="image-20230201193323608" style="zoom:80%;" />

### 使用禅道管理缺陷

#### 登录

![wecom-temp-733fc2924637799dc61c23b4020656c9](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720775.png)

#### 创建缺陷

![wecom-temp-6478a8fb72f4e88ff091ba184a3ec432](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720243.png)

![wecom-temp-e7efbcedba952aadb5a83e9b76ab65e0](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720082.png)

#### 关闭缺陷

![wecom-temp-ead870780da1b3c9fbdc704a51706b3b](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720628.png)



## 缺陷标题扩展

![image-20211027170926652](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720013.png)

### 作业讲解（day02）

![image-20211027121130395](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720567.png)

### 今晚作业

![image-20211027182846022](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011720715.png)

```
将以上测试点/功能点，转为用例。
```



# html介绍

#### 1.1 前端三大核心

- html:超文本标记语言，由一套标记标签组成
- 标签：
  - 单标签：`<标签名 />`
  - 双标签:`<标签名></标签名>`
  - 属性：`描述某一特征 示例:<a 属性名="属性值">`

#### 1.2 html骨架标签

​	![image-20211028093514517](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011807609.png)

```
html:根标签，所有的内容都应该放到html标签中
head：头部标签
body:身体标签（代码编写区域）
```

#### 1.3 注释

- 作用：描述的内容不会被浏览器执行
- 说明：解析程序给程序员看
- 快捷键：ctrl+/ `<!--注释区域-->`
- 测试点：`前端页面上线之前检查注释描述或去除注释`

#### 1.4 标签

- 标题：`h1~h6`

  - 说明：h1最大，h6最小

  - 示例：

    ```html
    <h1>我是h1</h1>
    <h6>我是h6</h6>
    ```

- 段落：`p`

  - 特点：语义化、独占一块（换行）

  - 示例：

    ```html
    <p>我是段落</p>
    ```

- 超链接`a`

  - 说明：`点击文本跳转到指定页面`
  - 语法：`<a href="https://www.baidu.com">文本</a>`
  - 属性：
    - href：跳转的地址或文件
    - target:打开窗口模式。`新窗口：target="_blank"`

- 图片

  - 说明：`在页面中插入一张图片`

  - 测试点：必须有title属性（悬停和未加载显示）

  - 示例

    ```html
    <!--
    			图像标签：img
    			属性：
    				src:图片路径
    				title：悬停显示文字
    				width:宽100px   px:像素
    				height:高 
    				alt:图片未加载显示
    		-->
    		<img src="011.jpg" title="希望在田野" width="100px" height="200px" 
                 alt="此处有一张田野照片"/>
    ```

- 空格与换行

  - 空格：`&nbsp;`     `&->shift+7`
  - 换行：`<br />`

- 布局标签

  > 布局：设置页面布局，便于排版

  - 大盒子：div、独占一行
  - 小盒子：span、一行可以放多个

- 列表

  ![image-20211028151747236](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011807613.png)

  ```yacas
  script:js标签
  style:css标签
  link:外部加载css标签
  ```

- input标签

  - 文本框：`<input type="text" />`

  - 密码框：`<input type="password" />`

  - 单选按钮：<input type="radio">

  - 复选框：<input type="checkbox">

  - 按钮：

    - 普通：type=button

    - 提交：type=submit

    - 重置: type=reset

      ```yacas
      <!--
      				按钮测试点：统一使用value进行赋值
      			  提示：普通按钮默认没有执行效果，需要配合Js来实现。
      -->
      ```

- form标签

  - 作用：提交页面输入的数据到指定页面或后台

  ```yacas
  <!--
  			form
  				作用：将页面输入的数据提交到后台或指定页面
  				属性：
  					action：  指定将数据提交到那个页面。
  					method:提交参数的方法（get、post）
  						get:查询使用
  							1、参数url明文显示
  							2、提交速度快
  							3、提交参数有长度限制
  						post:提交数据、登录、注册
  							1、非明文显示
  							2、提交速度慢
  							3、提交参数的长度无限制
  -->
  ```

  ```html
  <form action="10-接受数据.html" method="get">
  			用户名：<input type="text" name="username"/>
  			<br />
  			密码框：<input type="password" name="password"/>
  			<br />
  			<!--
  				单选效果：
  					1、相同一组的radio才能做单选。
  					2、设置相同（组名）name属性值为一组。
  			-->
  			性别：
  			<input type="radio" name="one"/>男
  			<input type="radio" name="one"/>女
  			<br />
  			您的爱好：
  			<input type="checkbox" />挣钱
  			<input type="checkbox" />吃饭
  			<input type="checkbox" />欣赏美
  			<input type="checkbox" />个人发挥
  			<br />
  			<input type="submit" />
  			<input type="reset" />
  			<input type="button" value="点我试试"/>
  		</form>
  ```

### 二 、作业

```
登录模块设计用例
```

![image-20211028171722419](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011807615.png)









# 今天目标

- 针对登录模块实施测试设计
- 针对发布文章模块实施测试设计

---

### 一、项目介绍

- 类型：web资讯管理平台（黑马头条）

- 子系统：

  ![image-20211029093320842](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808537.png)

- 实施模块（功能测试）

  - 登录
  - 发布文章

### 二、项目实施

```
1、分析需求
2、设计测试点
3、编写用例覆盖测试点
4、执行用例
5、缺陷管理
6、测试总结
```

#### 2.1 登录

- 需求

  ![image-20211228172020076](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808533.png)

- 测试点

  ![image-20211228172114741](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808537.png)

- 用例（登录成功、手机号逆向）

  ![image-20211228172322555](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808546.png)

- 用例（验证码逆向）

- 用例（兼容、布局）

  ![image-20211228172424781](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808545.png)

- 滑块

  ![image-20211228172443317](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808309.png)

#### 2.2 发布文章

- 需求

  ![image-20211029163304819](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808087.png)

- 测试点


  ![image-20211228172223248](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808097.png)

- 用例（发布文章）

  ![image-20211228172521509](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302011808984.png)





- 上传图片

  



# 该死的单元测试

今天跟大家来聊一聊，单元测试到底该怎么写？好了，说了这么多，相信你对单测应该有所了解了吧？

> **最重要的还是对单测有个正确的认识**，然后掌握 mock 的技巧，写新方法的时候，尝试设计完接口后，先写下单测，慢慢的你就会有感觉了，在写单测时，你自然而然地会考虑到诸多边界值的处理，你写的代码质量也会提高，渐渐地就会感受到单测的好处。

## 到底什么是单元测试

这个问题看似非常简单，单元测试嘛，不就是咱们开发自己写些测试类，来测试自己写的代码逻辑对不对。

这句话没有问题，但是不够准确。

首先我们要明白，这个测试二字前面还有两个字：**单元**。**它要求我们的测试粒度，小。**

具体来说就是一个 Test 仅测试一个方法，对这句话的认识非常重要。市面上常见的错误单测是怎样的呢：

> **把整个项目启动**，开始玩真的调用，入参是数据库里面真的值，所有的操作都落库，一个 Test 从 controller 到 service 再到 dao，一条龙打通。

> 这种不叫单元测试，**这叫集成测试**。如果你现在写的是这样的“单测”，你就会发现，写个测试类不仅要依赖数据库，还要依赖缓存，依赖公司别的团队的服务，亦或是一些三方开放平台的 Http 服务。

当我们的测试类需要依赖太多太多外部因素的时候，只要有一个地方出现问题，你的测试就是 fail 的。

并且入参和出参不能“任你摆布”，你还得想着如何控制别的团队的服务返回你想要的数据。

比如我想测试当依赖的服务 A 返回 sucess 时，我的代码逻辑的正确性，还得想测试服务 A 返回 fail 的逻辑，还得想测试它返回 null 的逻辑。

再包括数据库或者缓存的一些返回值的定制，这非常的困难，已经开始劝退人了。

然后**把整个项目启动**，这通常需要花费数分钟甚至数十分钟的时间，写两个单测一下午过去了，时间都花在调试的启动上了。

所以才会有那么多程序员觉得，单测好难写啊，又耗时，还动不动就 fail，写个 P。

所以回过头来看，到底什么是单测？

> 在 Java 中，单元测试的对象是类中的某个方法，一个 Test 只需要关心这个方法的逻辑正确性，仅仅测试这个方法的逻辑，不应该也不需要关注外部的逻辑。

举个例子，当你写 service 单测的时候，你压根就不应该测试 dao 或者外部服务返回的对不对，这是属于它们的逻辑，跟 service 没有关系。

可能听着感觉不强烈，我拿代码举个例：

<img src="https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGsOztoGKAx9VfEYarC7yqoY5xSjg7Lp5LBjOzMXtKhHCFy2az3rYVzlJDhEO252ulxu6icmWVy2FA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 80%;" />

假设我们要测试 `trainingYes` 这个方法，可以看到方法内部依赖 `yesDao` 和 `OneOneZeroProvicer`，一个是数据库，一个是 RPC 服务。

**这时候我们的思维应该是**：不管传入的 id 在数据库中对应的 yes 数据到底如何，我想让 `yesDao` 返回 null 的时候它就要返回 null ，想让它不为 null 就不为 null。

对 `OneOneZeroProvicer`也是一样，我想随意操控让它返回  false 或者 true。

因为数据库和外部服务的逻辑跟我当前的这个 service 方法没关系，**我只需要拿到我应该拿到的值来测试我的方法内部的所有逻辑分支即可**。

只有这样，我们才能容易地测试到我们所写的代码逻辑。

你想想看，如果你要是测着 `trainingYes` 还得管着到底哪个 id 能拿到值啊，然后这个 `yesDao#getYesById` 内部逻辑有没有状态过滤啊，这个 id 对应的数据有被废弃吗，需要关心这个那个，这就非常累了。

再或者你想关心 `OneOneZeroProvicer#call`怎样才能返回 true，怎样才能返回 false，这就更难了，因为这是别的团队的服务，你连这个服务的代码权限都没，一个一个去问别人？

万一没这样的数据呢，还得去造？

总而言之，单元测试仅需要关注自己方法内部的逻辑，不需要关注依赖方。

看到这，很多同学就搞不懂了，那该怎么搞？我的代码就是依赖它们的服务了啊。

**这就涉及到 mock 了**。

mock 指的是伪造一个假的依赖服务，替换真正的服务，在上面的例子中，需要伪造 `yesDao` 和 `OneOneZeroProvicer`，我们操控它们得到我们想要的返回值，满足我们自身对 `trainingYes` 的测试需求。

我拿 `yesDao `举例一下，如下所示，我 mock 了一个假的 dao：

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGsOztoGKAx9VfEYarC7yqoVW9c9XJklgwkRicn8PUt5CCrtAXNDDE604TGAhNbibEBE7XGHTeq8ibWA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

然后**在单测时通过反射或者 set 注入的方式把 MockYesDao 注入到测试的 YesService 中**， 这样一来，是不是就能控制逻辑了？

当我传入的 id 是 1 的时候，百分百拿到一个不是 null 的 yes 对象，当传入其他值的时候，肯定拿到的是 null，这样就非常容易控制我要测试的逻辑。

当然，**上面仅仅只是举例说明 mock 的含义的具体作用方式，实际上真正单测的时候没有人会手动写 mock 服务，基本上用的都是 mock 框架**。

比如我用的就是 mockito，这个我们后面再提。

至此，你应该对如何写单测有点感觉了，我简单总结下上面说的几个小点：

1. 单测不应该启动整个项目（包括 Spring 容器），没有这个必要，耗时长。
2. 单测不应该关心依赖的服务，包括 Dao、provider 等其它服务，需要通过 mock 来解耦。
3. 一个测试方法只测当前要测试的一个类中的一个方法。

其实就是分而治之的思想，本身在写代码的时候你已经为了降低复杂度和解耦，把代码分成了一个一个模块，一个一个方法，而单元测试的目的，本就是验证这些你拆分的方法自身逻辑的正确性。

## 为什么单测这么难写

在对单测有点感觉之后，我们再来盘一盘为什么单测这么难写。

核心原因在于，**我们本身写的代码不够解耦**。

看到这有人不服了，什么？单测难写还怪我本身写的代码不好，难写是因为本身的业务逻辑复杂！

好吧，这里需要强调一下，逻辑简单的类，其实没必要写单测，一般只是领导要求纯粹的追求覆盖率的时候，才会把这种简单的类补上去。

举个很简单的例子：`studentService.getStudentById(Long id)`，我相信你都能脑补里面的逻辑，你要说你就想为这样的方法写单测，这当然可以，但是收益不大。

单测收益最高的就是针对那些复杂的场景，比方说在开发周期比较紧急的时候，核心的、容易出错的逻辑才是更应该去重视的地方（要是开发周期空闲，你要补哪都行）。

回到单测难写的问题上，用专业术语来讲，就是**你写的代码可测试性不高**，导致难以编写对应的单测类。

怎样的代码是可测试性不高呢？我举个非常简单的例子：

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGsOztoGKAx9VfEYarC7yqo9jibf4Etj2KCMfTKZ3cruq9LfQzdZVhkk7IheE5hIf3ZW7jDzqysDnw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

假设你要给 `garbageMethod` 写个单测，是不是有点难？

里面用到了静态方法，又 new 了个 service。

这静态方法我想让返回值等于 111，我只能去研究里面的逻辑。有人可能想不就是一个方法的逻辑吗，就看看呗。

那就看看：

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGsOztoGKAx9VfEYarC7yqoic9KcAYV5bQJ6Tg996XkPJ2qWNTlF7pVgSQeGWTdu1xlEbe8Xk9uLmA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)可能你会说，这两分钟我就看明白了，但是这才一个，要是好多都需要看呢？

你为了测试当前的方法，且花了一堆时间去理解别的不需要测试的类的逻辑，这做法本身就不符合逻辑。

然后那个 noSevice 是 new 的，这如何控制它的返回值啊？我想 mock 这个类也替换不了啊！

所以，这样的代码就是可测试性低的代码，不好 mock （当然，mock 框架支持静态方法的 mock，不过 new noSevice 不好弄，当然一般人都不会这样写的，我只是为了举例）。

还有各种类之间有继承关系的，这种测试难度都比较大。

就是上面的种种原因，导致我们的单测难以编写。

所以如果我们在设计接口的时候，先编写单测，我们写出来的代码其实可测试性就很高了，因为你完全晓得这样的写法会使得你单测很难进行下去，自然而然你写的代码就会往解耦的方向发展（比如上面的 noService 肯定会注入）。

接下来，列举下具体哪几种代码写法使得我们单测难以编写：

1. 静态方法（不好 mock 替换注入，不过现在 mock 框架已支持）。
2. 内部直接 new ，强依赖，无法 mock 替换注入。
3. 继承类，测试当前类的方法逻辑，还需要关心父类逻辑和 mock 父类的服务（所以我们常说组合优于继承）。
4. 全局变量，这个应该好理解，好方法都公用，你改了值之后，会影响别的测试类，特别是并发执行测试类时，就傻了。
5. 时间等一些未决行为，代码里面有 new Date，逻辑是近 15 天可行，然后超过 15 天就跑不通了（当然可以通过动态计算时间）。

这里我要强调下，不是说上面的这几种代码不能写，这是不现实的，我只是列举说明这几种可能会使得你的单测不好写，**当然第 2 点就是不能写的**。

## 写个单测例子

说了那么多，不如实战一下，我就拿  `trainingYes` 来举例说明，这里引入 mockito 测试框架。

可以看到，通过注解 mock 类需要 mock 的 dao 和 provider ，然后将其注入到我们要测试的 `yesService` 中。

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGsOztoGKAx9VfEYarC7yqoE1BrQfDBx6LadicnxYfFxPGQfa9eqPSCgDztCE80ma7lpGHQoytia4oQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

接下来就是具体的逻辑，根据场景我一共写了 4 个方法来测试：

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGsOztoGKAx9VfEYarC7yqolEz5ouqVDTj9GxkWVFx0UFdbKsoHoyKkWSBYZOaAR7VcfVfaQfRpLg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)里面的 `when(xxxx).thenReturn(xxx)`，就是我们指定的 mock 逻辑，这就是指哪打哪，随心所欲。

我们跑一下，你看就很快，59 ms，也不需要 Spring 框架。

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGsOztoGKAx9VfEYarC7yqoialURM5ZeZibLtCDqWQLOSjfmqg7detH4RzUDq2UrOzOHrXic86xbLt6w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

就是通过这样的 mock 手段，忽略了依赖的服务的逻辑，使得我们要它怎样就怎样，便于我们单测类的编写。

至于具体的 mockito 的使用方式，大家可以网上搜看看，挺简单的。

然后上面提到的静态方法的模拟，也简单的，我截个网上的例子：

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGsOztoGKAx9VfEYarC7yqoiaTx7RTgL52DC9F7rMw5nlNmhAOFZiaibSMJVgWC30yWrrkjfW6r4UIicg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)上面的逻辑就是模拟静态方法 StaticUtils.name ，跟普通对象不同的是，它用完之后需要 close 一下，所以用了 try-with-resource，当然也可以手动 close，原理这里不做展开，有兴趣的小伙伴可以自己去了解下。

看到这，想必你对单测应该已经挺有感觉了吧?

## 道阻且长

知道了单测如何写和为什么难写之后，其实我们的思路已经清晰了，但是往往现实还是残酷的。

以前的老代码，巨多，领导要求补，难！一个 service 依赖十几个服务，mock 都 mock 傻了，难！

项目太紧急了，从长远来看，单测的收益会使得整体开发和后期维护的时间短，但是领导就是要求下周一上线，难！

我个人认为一些稳定的代码，除非现在真的没事做了，完全没必要去补单测，完全可以在改动对应的点的时候再去补，然后新写的方法都要求上单测，这是非常合理的。

如果写业务的时候，同步写单测，会促进你的思考，捋清思路，写出的代码因为可测试性高，自然而然就比较漂亮和解耦。还有一点也很重要，其实我们写单测的时候，不应该过多地关注内部的逻辑，举个非常简单的加法例子，我们单测只关心 add(1,1) 的结果是 2，不管里面实现到底是位运算还是啥运算？

因为只有当我们的单测没有过度地关心内部实现时，之后方法的具体实现变更（从普通的 +，变成了位运算），我们的单测才不需要进行对应的修改。

但实际上这种情况对我们业务不太适用。

举个例子， `YesService` 之前依赖 `yesDao`，现在这个 Dao 被剥离了，变成了另一个 RPC 服务，对应的我们之前所有的测试用例还是需要更改的，这是没办法的事情。

不过为什么我还要提一下这点呢？

比如你的测试方法里面有个 `xxxService.save` 逻辑，这个方法没有返回值，后面的逻辑也不依赖它，那么就不要想着在单测时候写 `verify(xxxService.save(..));`来验证这个方法是否被调用。

这样验证是否被调用其实意义不是很大，并且之后如果 xxxService 被移除了，单测就抛错了，因为里面没有调用`xxxService.save`，你还需要把这个单测给修复了。

这就是我所说的，写单测的时候，不要过度关注方法内部实现（有些需要 mock 的没办法）。

很多公司单测之所以推行不下去，就是因为没有一个很好的宣讲，或者缺乏对单测的系统介绍。

我相信大家都是在一年中的某个月份，领导在会上突然来了一句话：我们接下来要写单测！下个月覆盖率要达到 50%！

然后大家就吭哧吭哧开始写了，写么又是抄网上的一些例子，把整个项目一起，就进行集成测试了，然后写着写着，有人把数据库改了，跑得好好的单测就挂了。

要么就是写死数据，这个月单测是行的，下个月就挂了。

也没有人告诉你这单元测试写得不对，咱不是说写在 test 包里面的代码就叫单元测试。

一开始气势汹汹，后面虎头蛇尾，这就是绝大公司执行单测的真实写照。

领导很心痛，为什么就推不下去，大家都这么不积极，这么没有主人翁精神吗？

下属头痛加手痛，这啥玩意啊，是人写的吗？

**就这样，每年的某个时刻，你的领导都会突发开始抓单测，然后持续几周或一个月，热情逐渐消退，最后无人问津，领导也假装不知道**。

如此往复，年复一年。



# 单元测试JUnit

[JUnit 5 单元测试教程](https://mp.weixin.qq.com/s?__biz=MzI1MDIxNjQ1OQ==&mid=2247485046&idx=1&sn=63f61735a1faae5b868a49bd7c55058d&chksm=e984ef12def366045ee48bf34504d526b197d6ed69f3150ab590bcea833b538f3fb5a9985ade&mpshare=1&scene=23&srcid=1218eJDatRVnExP4iiB19lj7&sharer_sharetime=1671377468486&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

今天带大家体验了一把Spring Boot Test，作为Spring Boot官方测试框架，确实功能很强大。由于其主要基于JUnit 5，和JUnit 5的用法基本一致。使用它进行单元测试，无需启动整个项目，更快更好用！

> JUnit 5官方文档：https://junit.org/junit5/docs/current/user-guide/
>
> 项目源码地址：https://github.com/macrozheng/mall-learning/tree/master/mall-tiny-test

> 之前把我的[mall项目升级到Spring Boot 2.7](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247500820&idx=1&sn=9895bd4c39b90d45eb2a10efedb236ac&scene=21#wechat_redirect)的时候，很多之前的测试方法都不能用了，原来是Spring Boot Test已经升级支持JUnit 5了。今天我们来聊聊新版Spring Boot Test的使用，有了它，我们就不需要再使用main方法来测试了！

## JUnit 简介

> JUnit是一款Java语言的单元测试框架，目前大多数Java开发环境都已经支持它了。JUnit测试也就是所谓的白盒测试，在程序员知道程序内部逻辑的基础上进行的测试，使用JUnit能让我们快速地完成单元测试。Spring Boot Test将JUnit和其他测试框架结合起来，提供了便捷高效的测试手段，目前Spring Boot 2.7版本采用的是JUnit 5。

## 常用注解

> 在使用Spring Boot Test之前，我们先来了解下它常用的注解，这对使用它很有帮助，具体参考下表即可！

| 注解                  | 作用                                                         |
| :-------------------- | :----------------------------------------------------------- |
| @SpringBootTest       | 用于指定测试类启用Spring Boot Test，默认会提供Mock环境       |
| @ExtendWith           | 如果只想启用Spring环境进行简单测试，不想启用Spring Boot环境，可以配置扩展为：SpringExtension |
| @Test                 | 指定方法为测试方法                                           |
| @TestMethodOrder      | 用于配置测试类中方法的执行顺序策略，配置为OrderAnnotation时，按@Order顺序执行 |
| @Order                | 用于配置方法的执行顺序，数字越低执行顺序越高                 |
| @DisplayName          | 用于指定测试类和测试方法的别名                               |
| @BeforeAll            | 在测试类的所有测试方法前执行一次，可用于全局初始化           |
| @AfterAll             | 在测试类的所有测试方法后执行一次，可用于全局销毁资源         |
| @BeforeEach           | 在测试类的每个测试方法前都执行一次                           |
| @AfterEach            | 在测试类的每个测试方法后都执行一次                           |
| @Disabled             | 禁用测试方法                                                 |
| @RepeatedTest         | 指定测试方法重复执行                                         |
| @ParameterizedTest    | 指定参数化测试方法，类似重复执行，从@ValueSource中获取参数   |
| @ValueSource          | 用于参数化测试指定参数                                       |
| @AutoConfigureMockMvc | 启用MockMvc的自动配置，可用于测试接口                        |

## 基本使用

> 下面我们来聊聊这些注解的基本使用，通过它们可以实现一些基本的单元测试。

### 集成Spring Boot Test

如果你想在项目中集成Spring Boot Test的话，需要先在`pom.xml`中添加如下依赖。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

使用注解进行 JUnit 单元测试，直接引入 `junit-jupiter`即可。SpringBoot无需引入该依赖

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
      <version>5.9.1</version>
    <scope>test</scope>
</dependency>
```

### 最简单的测试

我们先来一个最简单的单元测试，使用`@SpringBootTest`注解启用单元测试，使用`@Test`指定测试方法，使用`Assertions`类的方法来断言结果是否符合预期，具体代码如下。

```java
@SpringBootTest
public class FirstTest {
    @Test
    public void test() {
        int a=1;
        Assertions.assertEquals(1,a);
    }
}
```

然后点击测试方法左侧按钮即可进行测试。

<img src="https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwnfogj5htTKn9vosGoA2jZtwMWCiagsVVQnCjRDgiczmz36aiaqWrEtG2hl3xaWCRnwDAqMdtPN1RdTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

执行完成后我们在IDEA的执行窗口中就可以看到方法测试通过了，由于使用`@SpringBootTest`启用了Spring Boot环境，日志中会输出Spring Boot的banner。

![图片](https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwnfogj5htTKn9vosGoA2jZtFnL6t50tyFPBXZiciaiaPcBBKxPaiaapuETiaUOU8TVM35SyTtdKibjpOmww/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210192341287.png" alt="image-20221019234132195" style="zoom:80%;" />



### 指定测试方法顺序和名称

我们可以通过`@TestMethodOrder`注解和`@Order`注解来指定所有测试方法的执行顺序，具体代码如下。

```java
/**
 * JUnit指定方法测试顺序
 * Created by macro on 2022/10/10.
 */
@ExtendWith(SpringExtension.class)
@Slf4j
public class MethodOrderTest {

    @Test
    @Order(1)
    @DisplayName("order为1的方法")
    void lowOrder(){
        log.info("lowOrder method");
    }

    @Test
    @Order(10)
    @DisplayName("order为10的方法")
    void highOrder(){
        log.info("highOrder method");
    }
}
```

- 点击类左侧测试按钮，可以直接运行该类中的所有测试方法。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210200908605.png" alt="image-20221020090859527" style="zoom:80%;" />

- 这里由于我们使用了`@DisplayName`注解给测试方法取了个别名，而且我们使用了`@ExtendWith`指定了运行环境为Spring而不是Spring Boot，所以日志中不会出现Spring Boot的banner，执行速度也更快。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210200909562.png" alt="image-20221020090920496" style="zoom:80%;" />

### 生命周期测试⭐

我们还可以通过JUnit 5的生命周期注解来执行测试方法，比如在`@BeforeAll`注解指定的方法中做全局初始化，在`@AfterAll`注解指定的方法中做资源的销毁，具体代码如下。

> 使用 @BeforeAll可以在单元测试前初始化部分信息，@BeforeAll 只能使用在静态方法上，被注解的方法会在测试开始前**运行一次**。

> 使用 `@BeforeEach` 注解的方法，会在每一个 `@Test` 注解的方法运行前运行一次。

> `@AfterAll` 注解只能使用在**静态方法上**，被注解的方法会在所有单元测试运行完毕后运行一次。

> 使用 `@AfterEach` 注解的方法，会在**每一个** `@Test` 注解的方法运行**结束前运行一次**。

```java
@SpringBootTest
@Slf4j
public class Test1 {

    @BeforeAll
    static void allInit(){
        log.info("allInit()：在所有方法前执行，只执行一次");
    }

    @BeforeEach
    void eachInit(){
        log.info("eachInit()：在测试方法前执行，每个测试方法前都执行");
    }

    @Test
    void successTest() {
        log.info("successTest()：方法执行成功");
    }

    @AfterEach
    void eachDown(){
        log.info("eachDown()：在测试方法后执行，每个测试方法后都执行");
    }

    @AfterAll
    static void allDown(){
        log.info("allDown()：在测试方法后执行，每个测试方法后都执行");
    }
    
}
```

测试完成后，控制台输出日志如下。

![图片](https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwnfogj5htTKn9vosGoA2jZtIKrq1y05wkH7LzB5rwBE5hUUSg5W5zodMBL6HDBtvtW7ZAJentr33A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 断言的使用

> 我们可以通过`Assertions`类中提供的断言API来断言测试结果。

例如我们可以使用`fail`方法直接断言方法执行失败并输出提示信息。

```java
/**
 * JUnit断言测试
 * Created by macro on 2022/10/11.
 */
@ExtendWith(SpringExtension.class)
public class AssertTest {

    @Test
    void failTest() {
        Assertions.fail("failTest()：方法执行失败");
    }
}
```

- 测试方法执行后会直接抛出异常信息。

![图片](https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwnfogj5htTKn9vosGoA2jZt3V5VX2Xtq2UpiaII9rENytu0oWKicHsgDTpDlPSWmibyKuvHEcWibt2eiag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 还可以通过`assertTrue`、`assertNull`、`assertEquals`这类方法来断言结果是否符合预期。

```java
/**
 * JUnit断言测试
 * Created by macro on 2022/10/11.
 */
@ExtendWith(SpringExtension.class)
public class AssertTest {

    @Test
    void failTest() {
        Assertions.fail("failTest()：方法执行失败");
    }

    @Test
    void trueTest(){
        Assertions.assertTrue(1==1);
    }

    @Test
    void trueFalse(){
        Assertions.assertFalse(3<=2);
    }

    @Test
    void nullTest(){
        String str = null;
        Assertions.assertNull(str);
    }

    @Test
    void notNullTest(){
        String str = "test";
        Assertions.assertNotNull(str);
    }

    @Test
    void equalsTest(){
        String str1 = "test";
        String str2 = "test";
        Assertions.assertEquals(str1,str2);
    }

    @Test
    void notEqualsTest(){
        String str1 = "test";
        String str2 = "test";
        Assertions.assertNotEquals(str1,str2);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210200917762.png" alt="image-20221020091714694" style="zoom:80%;" />

也可以使用`assertThrows`方法来断言方法中抛出的异常。

```java
/**
 * JUnit断言测试
 * Created by macro on 2022/10/11.
 */
@ExtendWith(SpringExtension.class)
public class AssertTest {

    @Test
    void throwsTest(){
        Assertions.assertThrows(NullPointerException.class,()->{
            String str = null;
            log.info(str.toLowerCase());
        });
    }
}
```

- 还可通过`assertTimeout`方法断言方法的执行时间。

```java
/**
 * JUnit断言测试
 * Created by macro on 2022/10/11.
 */
@ExtendWith(SpringExtension.class)
public class AssertTest {
    @Test
    void timeoutTest(){
        Assertions.assertTimeout(Duration.ofMillis(1000),()->{
            long sleepTime = 2000;
            ThreadUtil.sleep(sleepTime);
            LOGGER.info("timeoutTest():休眠{}毫秒",sleepTime);
        });
    }
}
```

- 或者通过`assertAll`方法将几个断言结合起来使用，`Assertions`类中提供的工具方法很多，具体可以参考它的代码。

```java
/**
 * JUnit断言测试
 * Created by macro on 2022/10/11.
 */
@ExtendWith(SpringExtension.class)
public class AssertTest {
    @Test
    void assertAllTest(){
        Assertions.assertAll(()->{
            trueTest();
        },()->{
            nullTest();
        },()->{
            equalsTest();
        });
    }
}
```

### 其他测试⭐

#### 禁用测试

Spring Boot Test除了上述测试功能，还可以使用`@Disabled`来禁用某个测试方法。

被 `@Disabled` 注解的方法不在参与测试，下面对 `testIsDog` 方法添加了 `@Disabled` 注解。

```java
/**
 * JUnit其他测试
 * Created by macro on 2022/10/10.
 */
@ExtendWith(SpringExtension.class)
public class OtherTest {
    @Test
    @Disabled("用于测试@Disabled注解")
    void disabledTest() {
        LOGGER.info("disabledTest()：方法被执行");
    }
}
```

#### 循环测试

也可以使用`@RepeatedTest`来实现循环测试。

```java
/**
 * JUnit其他测试
 * Created by macro on 2022/10/10.
 */
@ExtendWith(SpringExtension.class)
public class OtherTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(LifecycleTest.class);
    private static int count = 0;

    @RepeatedTest(3)
    void repeatedTest() {
        count++;
        LOGGER.info("repeatedTest()：重复执行第{}次",count);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210200920307.png" alt="image-20221020092056252" style="zoom:80%;" />

#### 参数化测试

还可以通过`@ParameterizedTest`来进行参数化测试。

```java
/**
 * JUnit其他测试
 * Created by macro on 2022/10/10.
 */
@ExtendWith(SpringExtension.class)
public class OtherTest {

    @ParameterizedTest
    @ValueSource(ints = {1,2,3})
    public void parameterizedTest(int a){
        log.info("parameterizedTest()：a={}",a);
    }
}
```

- 运行以上测试方法后，具体测试结果如下。

![图片](https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwnfogj5htTKn9vosGoA2jZt1AI3RexiaBzibiaWItib7CMHSwic9bcW7ADvwqaiclkXtc5dDq6DnP7yKLIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 生命周期测试详解⭐

### @BeforeAll

使用 `@BeforeAll` 可以在单元测试前初始化部分信息，`@BeforeAll` 只能使用在静态方法上，被注解的方法会在测试开始前**运行一次**。

```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
/** 
 * @author:https://www.wdbyte.com  
 **/
class JUnitBeforeAll {

    @BeforeAll
    public static void init() {
        System.out.println("初始化，准备测试信息");
    }

    @Test
    public void testIsDog() {
        String name = "dog";
        Assertions.assertEquals(name, "dog");
        System.out.println("is dog");
    }

    @Test
    public void testIsCat() {
        String name = "cat";
        Assertions.assertEquals(name, "cat");
        System.out.println("is cat");
    }
}
```

这会输出：

```
初始化，准备测试信息
is cat
is dog
```

### @BeforeEach

使用 `@BeforeEach` 注解的方法，会在每一个 `@Test` 注解的方法运行前运行一次。

```java
class JUnitBeforeAll {

    @BeforeAll
    public static void init() {
        System.out.println("初始化，准备测试信息");
    }

    @BeforeEach
    public void start(){
        System.out.println("开始测试...");
    }

    @Test
    public void testIsDog() {
        String name = "dog";
        Assertions.assertEquals(name, "dog");
        System.out.println("is dog");
    }

    @Test
    public void testIsCat() {
        String name = "cat";
        Assertions.assertEquals(name, "cat");
        System.out.println("is cat");
    }
}
```

这会输出：

```
初始化，准备测试信息
开始测试...
is cat
开始测试...
is dog
```

### @AfterAll

`@AfterAll` 注解只能使用在**静态方法上**，被注解的方法会在所有单元测试运行完毕后运行一次。

```java
class JUnitBeforeAll {

    @BeforeAll
    public static void init() {
        System.out.println("初始化，准备测试信息");
    }

    @BeforeEach
    public void start(){
        System.out.println("开始测试...");
    }

    @Test
    public void testIsDog() {
       //...
    }

    @Test
    public void testIsCat() {
        //...
    }

    @AfterAll
    public static void close() {
        System.out.println("结束，准备退出测试");
    }
}
```

这会输出：

```
初始化，准备测试信息
开始测试...
is cat
开始测试...
is dog
结束，准备退出测试
```

### @AfterEach

使用 `@AfterEach` 注解的方法，会在**每一个** `@Test` 注解的方法运行**结束前运行一次**。

```java
class JUnitBeforeAll {

    @BeforeAll
    public static void init() {
        System.out.println("初始化，准备测试信息");
    }

    @BeforeEach
    public void start(){
        System.out.println("开始测试...");
    }

    @Test
    public void testIsDog() { //... }

    @Test
    public void testIsCat() { //... }

    @AfterEach
    public void end(){
        System.out.println("测试完毕...");
    }

    @AfterAll
    public static void close() {
        System.out.println("结束，准备退出测试");
    }
}
```

这会输出：

```
初始化，准备测试信息
开始测试...
is cat
测试完毕...
开始测试...
is dog
测试完毕...
结束，准备退出测试
```

## JUnit 5 常用断言

在上面的例子中，已经用到了 `assertEquals` 来判断结果是否符合预期，`assertEquals`是类 `org.junit.jupiter.api.Assertions` 中的一个方法；除此之外，还几乎包括了所有我们日常测试想要用到的判断方法。

下面是一些演示：

```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class JunitAssert {

    @DisplayName("是否是狗")
    @Test
    public void testIsDog() {
        String name = "dog";
        Assertions.assertNotNull(name);
        Assertions.assertEquals(name, "dog");
        Assertions.assertNotEquals(name, "cat");
        Assertions.assertTrue("dog".equals(name));
        Assertions.assertFalse("cat".equals(name));
    }

    @DisplayName("是否是猫")
    @Test
    public void testIsCat() {
        String name = "cat";
        Assertions.assertNull(name, "name is not null");
    }
}
```

在 `testIsDog` 中演示了一些常用的判断方法，且都可以通过验证。在 `testIsCat` 方法中进行了 `null` 值判断，显然这里无法通过测试，会抛出自定义异常 `name is not null`。

这会输出：

```
org.opentest4j.AssertionFailedError: name is not null ==> 
Expected :null
Actual   :cat
<Click to see difference>
```

预期是一个 `null` 值，实际上是一个 `cat` 字符串。



## 项目实战

> 上面介绍了Spring Boot Test的基本使用，下面我们结合项目来使用下它。

### Dao层测试

如果我们的项目需要对数据访问层Dao中的方法进行测试的话，直接注入Mapper接口，在测试方法中直接调用即可，这里对根据ID查询品牌的Mapper方法进行测试。

```java
/**
 * Dao层方法测试
 * Created by macro on 2022/10/11.
 */
@SpringBootTest
public class MapperTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(MapperTest.class);

    @Autowired
    private PmsBrandMapper brandMapper;

    @Test
    void testGetById(){
        long id = 6;
        PmsBrand pmsBrand = brandMapper.selectByPrimaryKey(id);
        LOGGER.info("brand name:{}",pmsBrand.getName());
        Assertions.assertEquals("小米",pmsBrand.getName());
    }
}
```

### Service层测试

对业务层Service中的方法测试也是一样的，直接注入Service接口，在测试方法中直接调用即可，这里对根据ID查询品牌的Service方法进行测试。

```java
/**
 * Service层方法测试
 * Created by macro on 2022/10/11.
 */
@SpringBootTest
public class ServiceTest {
    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceTest.class);
    @Autowired
    private PmsBrandService brandService;

    @Test
    void testGetById(){
        long id = 6;
        PmsBrand pmsBrand = brandService.getBrand(id);
        LOGGER.info("brand name:{}",pmsBrand.getName());
        Assertions.assertEquals("小米",pmsBrand.getName());
    }
}
```

### Controller层测试

> 对于Controller层方法进行测试，有时我们需要模拟请求，使用MockMvc即可，这里模拟测试下分页查询品牌列表的接口。

```java
/**
 * Controller层方法测试
 * Created by macro on 2022/10/11.
 */
@SpringBootTest
@AutoConfigureMockMvc
public class ControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void mvcTest() throws Exception{
        //模拟发送一个请求访问分页查询品牌列表的接口
        mockMvc.perform(MockMvcRequestBuilders.get("/brand/list") //设置请求地址
                .param("pageNum","1") //设置请求参数
                .param("pageSize","5"))
                .andExpect(MockMvcResultMatchers.status().isOk()) //断言返回状态码为200
                .andDo(MockMvcResultHandlers.print()) //在控制台打印日志
                .andReturn(); //返回请求结果
    }
}
```

由于我们选择了在控制台输出日志，控制台将输出如下信息。

![图片](https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwnfogj5htTKn9vosGoA2jZtcwicwIjGqGALSVsibibEI0cnibrwaWoCotRWXkHgIItjia4T6oQecqPSX6w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



































































